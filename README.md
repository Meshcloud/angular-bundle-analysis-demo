# Angular Bundle Analysis Demo

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 1.6.4.

> note: all commands below are run from the ./myapp folder

## Tools

### Webpack Bundle Analyzer

[Webpack Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) is useful for analyzing the size of **all bundles** that make up your application. Its analysis is based on a `stats.json` file generated by webpack as part of an angular-cli build. This option needs to be explicitly enabled: `ng build --stats-json`.

Webpack Bundle Analyzer displays three different sizes. These are:
* **stat** This is the "input" size of your files, before any transformations like minification.
It is called "stat size" because it's obtained from Webpack's stats object.
* **parsed**
This is the "output" size of your files. If you're using a Webpack plugin such as Uglify, then this value will reflect the minified size of your code.
* **gzip** This is the size of running the parsed bundles/modules through gzip compression.

In this repository, invoke it using: 
```bash
yarn build && yarn wba
```

### Source Map Explorer

[Source Map Explorer](https://github.com/danvk/source-map-explorer) is useful for analyzing the contents of a single bundle in detail. As the name implies, it needs source-maps to do its job. We enable them during build: `ng build --sourcemaps`.

In this repository, invoke it on a bundle of your choice using: 
```bash
yarn build && yarn sme ./dist/$bundle.js
```

## Demos

The sample application in this repository shows a few interesting bits of bundling results. For each variant, there's a `build/*` branch that allows you to quickly check out a pre-built dist folder. 

The branches build upon each other. They are: 

### build/plain
A basic angular cli application skeleton generated using `ng new`.

Things to explore: 

- the overall bundle structure (main, inline, style).
- Getting familiar with Webpack Bundle Analyzer and Source Map Explorer
- Understanding JS modules vs. Angular Modules core concepts

### build/shared-module
This branch adds a simple angular `@NgModule` that contains a component with a significant amount of code (ok, it's just a few strings but hey ;-) ).

Things to explore: 
- how angular modules listed in `imports:[]` get included in the main bundle

### build/lazy-module-rxjs
This branch adds a lazy loaded feature module. The module is loaded via the router and uses some rxjs operators. The module imports rxjs using the "recommended" syntax for importing operators individually.

Things to explore: 

- how angular-cli splits feature modules into separate chunks
- "smart" import of rxjs operators into the feature module only (they're not used in the main chunk)

### build/rxjs-non-shakeable
This branch imports the complete rxjs library in one go to save import statements.

Things to explore: 

- a lot of unused operators end up in the feature module
- how JS modules affects ng-cli's/webpack's ability to tree-shake the application

### build/bootstrap-coarse-import
This branch imports the popular [ng-bootstrap](https://github.com/ng-bootstrap/ng-bootstrap) library using an import on `NgbModule.forRoot()`.

Things to explore: 

- grown bundle size even though no ng-bootsrap component is actually used
- how angular module imports affect ng-cli's/webpack's ability to tree-shake the application

### build/fine-grained-ngb
This branch imports ng-bootstrap using its individual feature modules. As a result, only used features of ng-bootstrap end up in the application. However, this approach requires more manual work to select the right imports.

Things to explore:

- reduced bundle size compared to branch `build/bootstrap-coarse-import`

### build/fine-grained-ngb-unused-directive
This branch shows what happens when we remove the usage of the `ngbTooltip` directive from our lazy feature module. 

Things to explore:

- reduced bundle size compared to branch `build/fine-grained-ngb`
- the different tree-shakeable and non-shakeable parts of a NgModule (For example, services are not tree-shaken, directives can be and components can be tree-shaken)